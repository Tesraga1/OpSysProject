#include <iostream>#include <cmath>#include <cstdio>#include <vector>#include <string>#include <cstdlib>#include <fstream>#include "Process.h"#include <iomanip>#include <algorithm>#include <queue>using namespace std;//Global Variablesint seed;double lambda;int bound;int t_cs;float alpha;int tslice;//overall average CPU burst time = totalCPU burst time / total CPU burstsdouble CPU_burst_time = 0;double CPU_total_bursts = 0;//overall average IO burst time = totalIO burst time / total IO burstsdouble IO_burst_time = 0;double IO_total_bursts = 0;//CPU Bound average CPU time = total CB CPU time / total CB CPU burstsdouble CB_CPU_time = 0;double CB_CPU_bursts = 0;//IO Bound average CPU time = total IB CPU time / total IB CPU burstsdouble IB_CPU_time = 0;double IB_CPU_bursts = 0;//CPU Bound average IO time = total CB IO time / total CB IO burstsdouble CB_IO_time = 0;double CB_IO_bursts = 0;//IO Bound average IO time = total IB IO time / total IBB IO burstsdouble IB_IO_time = 0;double IB_IO_bursts = 0;//will hold the CPU burst time and IO burst time for each CPU burstint CPU_burst = 0;int IO_burst = 0;void print_ready(vector<Process>& readyQueue, int starting){    int total = readyQueue.size();    if (total == 1 && starting == 0) {        printf("%s",readyQueue[0].returnID().c_str());        printf("]\n");    } else if (total == 1 && starting == 1) {        printf("empty]\n");    }    else if (starting == 2) {        for (int x = 0; x < total-1; x++){            printf("%s",readyQueue[x].returnID().c_str());            if (x != total-2){                printf(" ");            }        }        printf("]\n");    } else {        for (int x = starting; x < total; x++){            printf("%s",readyQueue[x].returnID().c_str());            if (x != total-1){                printf(" ");            }        }        printf("]\n");    }}void waiting(vector<Process>& readyQueue, int starting){    int total = readyQueue.size();    if (total == 1 && starting == 0) {        readyQueue[0].increment_wait_time();    } else if (total == 1 && starting == 1) {        return;    }    else if (starting == 2) {        for (int x = 0; x < total-1; x++){            readyQueue[x].increment_wait_time();        }    } else {        for (int x = starting; x < total; x++){            readyQueue[x].increment_wait_time();        }    }}bool compareByArrival(const Process &a, const Process&b) {    if (a.returnArrivalTime() == b.returnArrivalTime()) {        return a.returnID() < b.returnID();    }    return a.returnArrivalTime() < b.returnArrivalTime();}bool compareIO(const Process &a, const Process&b) {    if (a.returnBlockTime() == b.returnBlockTime()) {        return a.returnID() < b.returnID();    }    return a.returnBlockTime() < b.returnBlockTime();}bool shortestFirst(const Process &a, const Process&b) {    if (a.return_prediction() == b.return_prediction()) {        return a.returnID() < b.returnID();    }    return a.return_prediction() < b.return_prediction();}// FCFS: First-come-first-servedvoid FCFS(vector<Process> processList, FILE* outfile) {    printf("time 0ms: Simulator started for FCFS [Q empty]\n");    std::sort(processList.begin(), processList.end(), compareByArrival);    bool first = true;    bool cpu_in_use = false;    vector<Process> readyQueue;    vector<Process> io_list;    std::sort(io_list.begin(), io_list.end(), compareIO);    int current_time = 0;    double cpu_time = 0;    int new_process = 0;    int process_number = 0;    int switch_count = 0;    int cpu_switch_count = 0;    int io_switch_count = 0;    double cpu_wait_time = 0;    double io_wait_time = 0;    int cpu_burst_number = 0;    int io_burst_number = 0;    for(long unsigned int x = 0; x < processList.size(); x++) {        process_number += processList[x].numBursts();        if (processList[x].returnBound() == 0) {            cpu_burst_number += processList[x].numBursts();        } else {            io_burst_number += processList[x].numBursts();        }    }    double total_wait_time = 0;    double average_wait_time;    double turnaround = 0;    double cpu_turnaround = 0;    double io_turnaround = 0;    while(true){        if (cpu_in_use) {            if (readyQueue.size() > 1) {                waiting(readyQueue, 1);            }        } else {            waiting(readyQueue, 0);        }        if (readyQueue.size() > 0) {            if (cpu_in_use && current_time == readyQueue[0].returnEnd()){ //burst complete and switch                if (readyQueue[0].numBursts() != 1) {                    new_process = current_time + t_cs;                    readyQueue[0].burstComplete(current_time, (t_cs/2));                    if (current_time < 10000) {                        if (readyQueue[0].numBursts() == 1) {                            printf("time %dms: Process %s completed a CPU burst; %d burst to go [Q ", current_time, readyQueue[0].returnID().c_str(), readyQueue[0].numBursts());                        } else {                            printf("time %dms: Process %s completed a CPU burst; %d bursts to go [Q ", current_time, readyQueue[0].returnID().c_str(), readyQueue[0].numBursts());                        }                        if (readyQueue.size() == 0){                            printf("empty]\n");                        } else {                            print_ready(readyQueue, 1);                        }                        printf("time %dms: Process %s switching out of CPU; blocking on I/O until time %dms [Q ", current_time, readyQueue[0].returnID().c_str(), readyQueue[0].returnBlockTime());                    }                    io_list.push_back(readyQueue[0]);                    std::sort(io_list.begin(), io_list.end(), compareIO);                    if (current_time < 10000) {                        if (readyQueue.size() == 0){                            printf("empty]\n");                        } else {                            print_ready(readyQueue, 1);                        }                    }                    readyQueue.erase(readyQueue.begin());                    cpu_in_use = false;                } else {                    new_process = current_time + t_cs;                    printf("time %dms: Process %s terminated [Q ", current_time, readyQueue[0].returnID().c_str());                    if (readyQueue.size() == 0){                        printf("empty]\n");                    } else {                        print_ready(readyQueue, 1);                    }                    switch_count++;                    if (readyQueue[0].returnBound() == 0) {                        cpu_switch_count++;                    } else {                        io_switch_count++;                    }                    readyQueue[0].set_turnaround();                    turnaround += readyQueue[0].return_turnaround();                    if (readyQueue[0].returnBound() == 0) {                        cpu_turnaround += readyQueue[0].return_turnaround();                    } else {                        io_turnaround += readyQueue[0].return_turnaround();                    }                    total_wait_time += readyQueue[0].return_wait_time();                    if (readyQueue[0].returnBound() == 0) {                        cpu_wait_time += readyQueue[0].return_wait_time();                    } else {                        io_wait_time += readyQueue[0].return_wait_time();                    }                    readyQueue.erase(readyQueue.begin());                    cpu_in_use = false;                }            }            if (!cpu_in_use && first && current_time == new_process ) { //Burst start if first                first = false;                if (current_time < 10000) {                    printf("time %dms: Process %s started using the CPU for %dms burst [Q ", current_time, readyQueue[0].returnID().c_str(), readyQueue[0].returnBurst());                    if (readyQueue.empty()){                        printf("empty]\n");                    } else {                        print_ready(readyQueue, 1);                    }                }                cpu_in_use = true;                readyQueue[0].add_end(current_time + readyQueue[0].returnBurst());            }            if (!cpu_in_use && current_time == new_process) { //Burst start                if (current_time < 10000) {                    printf("time %dms: Process %s started using the CPU for %dms burst [Q ", current_time, readyQueue[0].returnID().c_str(), readyQueue[0].returnBurst());                    if (readyQueue.empty()){                        printf("empty]\n");                    } else {                        print_ready(readyQueue, 1);                    }                }                cpu_in_use = true;                readyQueue[0].add_end(current_time + readyQueue[0].returnBurst());            }        }        if (cpu_in_use) {            cpu_time++;        }        if (io_list.size() != 0) { //completing IO Block            if (current_time == io_list[0].returnBlockTime()) {                if (current_time < 10000) {                    printf("time %dms: Process %s completed I/O; added to ready queue [Q ", current_time, io_list[0].returnID().c_str());                }                switch_count++;                if (io_list[0].returnBound() == 0) {                    cpu_switch_count++;                } else {                    io_switch_count++;                }                readyQueue.push_back(io_list[0]);                io_list.erase(io_list.begin());                if (current_time < 10000) {                    if (readyQueue.empty()){                        printf("empty]\n");                    } else {                        if ((current_time < new_process)) {                            print_ready(readyQueue, 1);                        } else {                            if (!cpu_in_use) {                                print_ready(readyQueue, 0);                            } else {                                print_ready(readyQueue, 1);                            }                        }                    }                }                if (new_process <= current_time) {                    new_process = current_time + (t_cs/2);                }            }        }        if (processList.size() != 0) {            if (processList[0].returnArrivalTime() == current_time) { //add process to queue                if (first) {                    new_process = current_time + (t_cs/2);                }                if (current_time < 10000) {                    printf("time %dms: Process %s arrived; added to ready queue [Q ", current_time, processList[0].returnID().c_str());                }                readyQueue.push_back(processList[0]);                if (current_time < 10000) {                    if (readyQueue.empty()){                        printf("empty]\n");                    } else {                        if (first) {                            print_ready(readyQueue, 0);                        } else if (cpu_in_use) {                            print_ready(readyQueue, 1);                        }                    }                }                processList.erase(processList.begin());            }        } else if (readyQueue.size() == 0 && io_list.size() == 0) {            current_time += (t_cs/2);            break;        }        current_time++;    }    double avg_turnaround = ceil(((turnaround + switch_count*(t_cs/2))/process_number)*1000)/1000;    double avg_cpu_turnaround = ceil(((cpu_turnaround + cpu_switch_count*(t_cs/2))/cpu_burst_number)*1000)/1000;    double avg_io_turnaround = ceil(((io_turnaround + io_switch_count*(t_cs/2))/io_burst_number)*1000)/1000;    printf("time %dms: Simulator ended for FCFS [Q empty]\n", current_time);    total_wait_time-=(switch_count*(t_cs/2));    io_wait_time-=(io_switch_count*(t_cs/2));    cpu_wait_time-=(cpu_switch_count*(t_cs/2));    average_wait_time = ceil((total_wait_time/process_number)*1000)/1000;    double average_cpu_wait = ceil((cpu_wait_time/cpu_burst_number)*1000)/1000;    double average_io_wait = ceil((io_wait_time/io_burst_number)*1000)/1000;    double CPU_UTIL = 0;    if (cpu_time != 0 && current_time != 0) {        CPU_UTIL = cpu_time/(current_time);        CPU_UTIL = ceil(CPU_UTIL * 100000) / 1000;    }    fprintf(outfile, "Algorithm FCFS\n");    fprintf(outfile,"-- CPU utilization: %0.3f%%\n", CPU_UTIL);    fprintf(outfile,"-- CPU-bound average wait time: %0.3f ms\n", average_cpu_wait);    fprintf(outfile,"-- I/O-bound average wait time: %0.3f ms\n", average_io_wait);    fprintf(outfile,"-- overall average wait time: %0.3f ms\n", average_wait_time);    fprintf(outfile,"-- CPU-bound average turnaround time: %0.3f ms\n", avg_cpu_turnaround);    fprintf(outfile,"-- I/O-bound average turnaround time: %0.3f ms\n", avg_io_turnaround);    fprintf(outfile,"-- overall average turnaround time: %0.3f ms\n", avg_turnaround);    fprintf(outfile,"-- CPU-bound number of context switches: %d\n", cpu_switch_count);    fprintf(outfile,"-- I/O-bound number of context switches: %d\n", io_switch_count);    fprintf(outfile,"-- overall number of context switches: %d\n", switch_count);    fprintf(outfile,"-- CPU-bound number of preemptions: 0\n");    fprintf(outfile,"-- I/O-bound number of preemptions: 0\n");    fprintf(outfile,"-- overall number of preemptions: 0\n\n");}//// SJF: Shortest job firstvoid SJF(vector<Process> processList, FILE* outfile) {    printf("time 0ms: Simulator started for SJF [Q empty]\n");    std::sort(processList.begin(), processList.end(), compareByArrival);    bool first = true;    bool cpu_in_use = false;    vector<Process> readyQueue;    vector<Process> io_list;    std::sort(io_list.begin(), io_list.end(), compareIO);    int current_time = 0;    double cpu_time = 0;    int new_process = 0;    int old_pred;    int process_number = 0;    int switch_count = 0;    int cpu_switch_count = 0;    int io_switch_count = 0;    double cpu_wait_time = 0;    double io_wait_time = 0;    int cpu_burst_number = 0;    int io_burst_number = 0;    for(long unsigned int x = 0; x < processList.size(); x++) {        process_number += processList[x].numBursts();        if (processList[x].returnBound() == 0) {            cpu_burst_number += processList[x].numBursts();        } else {            io_burst_number += processList[x].numBursts();        }    }    double total_wait_time = 0;    double average_wait_time;    double turnaround = 0;    double cpu_turnaround = 0;    double io_turnaround = 0;    while(true){        if (cpu_in_use) {            if (readyQueue.size() > 1) {                waiting(readyQueue, 1);            }        } else {            waiting(readyQueue, 0);        }        if (readyQueue.size() > 0) {            if (cpu_in_use && current_time == readyQueue[0].returnEnd()){ //burst complete and switch                if (readyQueue[0].numBursts() != 1) {                    new_process = current_time + t_cs;                    old_pred = readyQueue[0].return_prediction();                    readyQueue[0].update_prediction(alpha, 0);                    readyQueue[0].burstComplete(current_time, (t_cs/2));                    if (current_time < 10000) {                        if (readyQueue[0].numBursts() == 1) {                            printf("time %dms: Process %s (tau %dms) completed a CPU burst; %d burst to go [Q ", current_time, readyQueue[0].returnID().c_str(), old_pred, readyQueue[0].numBursts());                        } else {                            printf("time %dms: Process %s (tau %dms) completed a CPU burst; %d bursts to go [Q ", current_time, readyQueue[0].returnID().c_str(), old_pred, readyQueue[0].numBursts());                        }                        if (readyQueue.size() == 0){                            printf("empty]\n");                        } else {                            print_ready(readyQueue, 1);                        }                        printf("time %dms: Recalculated tau for process %s: old tau %dms ==> new tau %dms [Q ",current_time, readyQueue[0].returnID().c_str(), old_pred, readyQueue[0].return_prediction());                        if (readyQueue.size() == 0){                            printf("empty]\n");                        } else {                            print_ready(readyQueue, 1);                        }                        printf("time %dms: Process %s switching out of CPU; blocking on I/O until time %dms [Q ", current_time, readyQueue[0].returnID().c_str(), readyQueue[0].returnBlockTime());                    }                    io_list.push_back(readyQueue[0]);                    std::sort(io_list.begin(), io_list.end(), compareIO);                    if (current_time < 10000) {                        if (readyQueue.size() == 0){                            printf("empty]\n");                        } else {                            print_ready(readyQueue, 1);                        }                    }                    readyQueue.erase(readyQueue.begin());                    cpu_in_use = false;                } else {                    new_process = current_time + t_cs;                    printf("time %dms: Process %s terminated [Q ", current_time, readyQueue[0].returnID().c_str());                    if (readyQueue.size() == 0){                        printf("empty]\n");                    } else {                        print_ready(readyQueue, 1);                    }                    switch_count++;                    if (readyQueue[0].returnBound() == 0) {                        cpu_switch_count++;                    } else {                        io_switch_count++;                    }                    readyQueue[0].set_turnaround();                    turnaround += readyQueue[0].return_turnaround();                    if (readyQueue[0].returnBound() == 0) {                        cpu_turnaround += readyQueue[0].return_turnaround();                    } else {                        io_turnaround += readyQueue[0].return_turnaround();                    }                    total_wait_time += readyQueue[0].return_wait_time();                    if (readyQueue[0].returnBound() == 0) {                        cpu_wait_time += readyQueue[0].return_wait_time();                    } else {                        io_wait_time += readyQueue[0].return_wait_time();                    }                    readyQueue.erase(readyQueue.begin());                    cpu_in_use = false;                }            }            if (!cpu_in_use && first && current_time == new_process ) { //Burst start if first                first = false;                if (current_time < 10000) {                    printf("time %dms: Process %s (tau %dms) started using the CPU for %dms burst [Q ", current_time, readyQueue[0].returnID().c_str(), readyQueue[0].return_prediction(), readyQueue[0].returnBurst());                    if (readyQueue.empty()){                        printf("empty]\n");                    } else {                        print_ready(readyQueue, 1);                    }                }                readyQueue[0].save_burst();                cpu_in_use = true;                readyQueue[0].add_end(current_time + readyQueue[0].returnBurst());            }            if (!cpu_in_use && current_time == new_process) { //Burst start                if (current_time < 10000) {                    printf("time %dms: Process %s (tau %dms) started using the CPU for %dms burst [Q ", current_time, readyQueue[0].returnID().c_str(), readyQueue[0].return_prediction(), readyQueue[0].returnBurst());                    if (readyQueue.empty()){                        printf("empty]\n");                    } else {                        print_ready(readyQueue, 1);                    }                }                readyQueue[0].save_burst();                cpu_in_use = true;                readyQueue[0].add_end(current_time + readyQueue[0].returnBurst());            }        }        if (cpu_in_use) {            cpu_time++;        }        if (io_list.size() != 0) { //completing IO Block            if (current_time == io_list[0].returnBlockTime()) {                if (current_time < 10000) {                    printf("time %dms: Process %s (tau %dms) completed I/O; added to ready queue [Q ", current_time, io_list[0].returnID().c_str(), io_list[0].return_prediction());                }                readyQueue.push_back(io_list[0]);                if (cpu_in_use) {                    std::sort(readyQueue.begin()+1, readyQueue.end(), shortestFirst);                } else {                    std::sort(readyQueue.begin(), readyQueue.end(), shortestFirst);                }                switch_count++;                if (io_list[0].returnBound() == 0) {                    cpu_switch_count++;                } else {                    io_switch_count++;                }                io_list.erase(io_list.begin());                if (current_time < 10000) {                    if (readyQueue.empty()){                        printf("empty]\n");                    } else {                        if ((current_time < new_process)) {                            print_ready(readyQueue, 1);                        } else {                            if (!cpu_in_use) {                                print_ready(readyQueue, 0);                            } else {                                print_ready(readyQueue, 1);                            }                        }                    }                }                if (new_process <= current_time) {                    new_process = current_time + (t_cs/2);                }            }        }        if (processList.size() != 0) {            if (processList[0].returnArrivalTime() == current_time) { //add process to queue                if (first) {                    new_process = current_time + (t_cs/2);                }                if (current_time < 10000) {                    printf("time %dms: Process %s (tau %dms) arrived; added to ready queue [Q ", current_time, processList[0].returnID().c_str(), processList[0].return_prediction());                }                readyQueue.push_back(processList[0]);                if (cpu_in_use) {                    std::sort(readyQueue.begin()+1, readyQueue.end(), shortestFirst);                } else {                    std::sort(readyQueue.begin(), readyQueue.end(), shortestFirst);                }                if (current_time < 10000) {                    if (readyQueue.empty()){                        printf("empty]\n");                    } else {                        if (first) {                            print_ready(readyQueue, 0);                        } else if (cpu_in_use) {                            print_ready(readyQueue, 1);                        }                    }                }                processList.erase(processList.begin());            }        } else if (readyQueue.size() == 0 && io_list.size() == 0) {            current_time += (t_cs/2);            break;        }        current_time++;    }    double avg_turnaround = ceil(((turnaround + switch_count*(t_cs/2))/process_number)*1000)/1000;    double avg_cpu_turnaround = ceil(((cpu_turnaround + cpu_switch_count*(t_cs/2))/cpu_burst_number)*1000)/1000;    double avg_io_turnaround = ceil(((io_turnaround + io_switch_count*(t_cs/2))/io_burst_number)*1000)/1000;    printf("time %dms: Simulator ended for SJF [Q empty]\n", current_time);    total_wait_time-=(switch_count*(t_cs/2));    io_wait_time-=(io_switch_count*(t_cs/2));    cpu_wait_time-=(cpu_switch_count*(t_cs/2));    average_wait_time = ceil((total_wait_time/process_number)*1000)/1000;    double average_cpu_wait = ceil((cpu_wait_time/cpu_burst_number)*1000)/1000;    double average_io_wait = ceil((io_wait_time/io_burst_number)*1000)/1000;    double CPU_UTIL = 0;    if (cpu_time != 0 && current_time != 0) {        CPU_UTIL = cpu_time/(current_time);        CPU_UTIL = ceil(CPU_UTIL * 100000) / 1000;    }    fprintf(outfile, "Algorithm SJF\n");    fprintf(outfile,"-- CPU utilization: %0.3f%%\n", CPU_UTIL);    fprintf(outfile,"-- CPU-bound average wait time: %0.3f ms\n", average_cpu_wait);    fprintf(outfile,"-- I/O-bound average wait time: %0.3f ms\n", average_io_wait);    fprintf(outfile,"-- overall average wait time: %0.3f ms\n", average_wait_time);    fprintf(outfile,"-- CPU-bound average turnaround time: %0.3f ms\n", avg_cpu_turnaround);    fprintf(outfile,"-- I/O-bound average turnaround time: %0.3f ms\n", avg_io_turnaround);    fprintf(outfile,"-- overall average turnaround time: %0.3f ms\n", avg_turnaround);    fprintf(outfile,"-- CPU-bound number of context switches: %d\n", cpu_switch_count);    fprintf(outfile,"-- I/O-bound number of context switches: %d\n", io_switch_count);    fprintf(outfile,"-- overall number of context switches: %d\n", switch_count);    fprintf(outfile,"-- CPU-bound number of preemptions: 0\n");    fprintf(outfile,"-- I/O-bound number of preemptions: 0\n");    fprintf(outfile,"-- overall number of preemptions: 0\n\n");}// SRT: Shortest remaning timevoid SRT(vector<Process> processList, FILE* outfile) {    printf("time 0ms: Simulator started for SRT [Q empty]\n");    std::sort(processList.begin(), processList.end(), compareByArrival);    bool first = true;    bool cpu_in_use = false;    vector<Process> readyQueue;    vector<Process> io_list;    std::sort(io_list.begin(), io_list.end(), compareIO);    int current_time = 0;    double cpu_time = 0;    int new_process = 0;    int difference = 0;    int old_pred;    int saved_pred;    bool preempt = false;    int process_number = 0;    int switch_count = 0;    int cpu_switch_count = 0;    int io_switch_count = 0;    double cpu_wait_time = 0;    double io_wait_time = 0;    int cpu_burst_number = 0;    int io_burst_number = 0;    int preemption_count = 0;    int cpu_preemption_count = 0;    int io_preemption_count = 0;    for(long unsigned int x = 0; x < processList.size(); x++) {        process_number += processList[x].numBursts();        if (processList[x].returnBound() == 0) {            cpu_burst_number += processList[x].numBursts();        } else {            io_burst_number += processList[x].numBursts();        }    }    double turnaround = 0;    double cpu_turnaround = 0;    double io_turnaround = 0;    double total_wait_time = 0;    double average_wait_time;    while(true){        if (cpu_in_use) {            readyQueue[0].reduceBurst();            cpu_time++;            saved_pred--;        }        if (cpu_in_use) {            if (readyQueue.size() > 1) {                waiting(readyQueue, 1);            }        } else {            waiting(readyQueue, 0);        }        if (readyQueue.size() > 0) {            if (cpu_in_use && current_time == readyQueue[0].returnEnd()){ //burst complete and switch                if (readyQueue[0].numBursts() != 1) {                    new_process = current_time + t_cs;                    old_pred = readyQueue[0].return_prediction();                    readyQueue[0].update_prediction(alpha, 0);                    readyQueue[0].burstComplete(current_time, (t_cs/2));                    if (current_time < 10000) {                        if (readyQueue[0].numBursts() == 1) {                            printf("time %dms: Process %s (tau %dms) completed a CPU burst; %d burst to go [Q ", current_time, readyQueue[0].returnID().c_str(), old_pred, readyQueue[0].numBursts());                        } else {                            printf("time %dms: Process %s (tau %dms) completed a CPU burst; %d bursts to go [Q ", current_time, readyQueue[0].returnID().c_str(), old_pred, readyQueue[0].numBursts());                        }                        if (readyQueue.size() == 0){                            printf("empty]\n");                        } else {                            print_ready(readyQueue, 1);                        }                        printf("time %dms: Recalculated tau for process %s: old tau %dms ==> new tau %dms [Q ",current_time, readyQueue[0].returnID().c_str(), old_pred, readyQueue[0].return_prediction());                        if (readyQueue.size() == 0){                            printf("empty]\n");                        } else {                            print_ready(readyQueue, 1);                        }                        printf("time %dms: Process %s switching out of CPU; blocking on I/O until time %dms [Q ", current_time, readyQueue[0].returnID().c_str(), readyQueue[0].returnBlockTime());                    }                    if (readyQueue[0].return_preempt()) {                        readyQueue[0].unpreempt();                    }                    io_list.push_back(readyQueue[0]);                    std::sort(io_list.begin(), io_list.end(), compareIO);                    if (current_time < 10000) {                        if (readyQueue.size() == 0){                            printf("empty]\n");                        } else {                            print_ready(readyQueue, 1);                        }                    }                    readyQueue.erase(readyQueue.begin());                    cpu_in_use = false;                } else {                    new_process = current_time + t_cs;                    printf("time %dms: Process %s terminated [Q ", current_time, readyQueue[0].returnID().c_str());                    if (readyQueue.size() == 0){                        printf("empty]\n");                    } else {                        print_ready(readyQueue, 1);                    }                    switch_count++;                    if (readyQueue[0].returnBound() == 0) {                        cpu_switch_count++;                    } else {                        io_switch_count++;                    }                    readyQueue[0].set_turnaround();                    turnaround += readyQueue[0].return_turnaround();                    if (readyQueue[0].returnBound() == 0) {                        cpu_turnaround += readyQueue[0].return_turnaround();                    } else {                        io_turnaround += readyQueue[0].return_turnaround();                    }                    total_wait_time += readyQueue[0].return_wait_time();                    if (readyQueue[0].returnBound() == 0) {                        cpu_wait_time += readyQueue[0].return_wait_time();                    } else {                        io_wait_time += readyQueue[0].return_wait_time();                    }                    readyQueue.erase(readyQueue.begin());                    cpu_in_use = false;                }            }            if (!cpu_in_use && first && current_time == new_process ) { //Burst start if first                first = false;                if (current_time < 10000) {                    printf("time %dms: Process %s (tau %dms) started using the CPU for %dms burst [Q ", current_time, readyQueue[0].returnID().c_str(), readyQueue[0].return_prediction(), readyQueue[0].returnBurst());                    if (readyQueue.empty()){                        printf("empty]\n");                    } else {                        print_ready(readyQueue, 1);                    }                }                saved_pred = readyQueue[0].return_prediction();                if (!readyQueue[0].return_preempt()) {                    readyQueue[0].save_burst();                }                cpu_in_use = true;                readyQueue[0].add_end(current_time + readyQueue[0].returnBurst());            }            if (!cpu_in_use && current_time == new_process) { //Burst start                if (current_time < 10000) {                    if (readyQueue[0].return_preempt()) {                        difference = readyQueue[0].return_saved_burst() - readyQueue[0].returnBurst();                        printf("time %dms: Process %s (tau %dms) started using the CPU for remaining %dms of %dms burst [Q ", current_time, readyQueue[0].returnID().c_str(), readyQueue[0].return_prediction(), readyQueue[0].returnBurst(), readyQueue[0].return_saved_burst());                    } else {                        difference = 0;                        printf("time %dms: Process %s (tau %dms) started using the CPU for %dms burst [Q ", current_time, readyQueue[0].returnID().c_str(), readyQueue[0].return_prediction(), readyQueue[0].returnBurst());                    }                    if (readyQueue.empty()){                        printf("empty]\n");                    } else {                        print_ready(readyQueue, 1);                    }                }                saved_pred = readyQueue[0].return_prediction();                if (!readyQueue[0].return_preempt()) {                    readyQueue[0].save_burst();                }                cpu_in_use = true;                readyQueue[0].add_end(current_time + readyQueue[0].returnBurst());            }        }        if (io_list.size() != 0) { //completing IO Block            if (current_time == io_list[0].returnBlockTime()) {                if (cpu_in_use) {                    if (io_list[0].return_prediction() < saved_pred) {                        if (current_time < 10000) {                            if (difference == 0) {                                printf("time %dms: Process %s (tau %dms) completed I/O; preempting %s (predicted remaining time "                                       "%dms) [Q ", current_time, io_list[0].returnID().c_str(), io_list[0].return_prediction(),  readyQueue[0].returnID().c_str(), saved_pred);                            } else {                                printf("time %dms: Process %s (tau %dms) completed I/O; preempting %s (predicted remaining time "                                       "%dms) [Q ", current_time, io_list[0].returnID().c_str(), io_list[0].return_prediction(),  readyQueue[0].returnID().c_str(), saved_pred - difference);                            }                        }                        preemption_count++;                        if (readyQueue[0].returnBound() == 0) {                            cpu_preemption_count++;                        } else {                            io_preemption_count++;                        }                        readyQueue[0].set_preempt();                        readyQueue.push_back(readyQueue[0]);                        readyQueue[0] = io_list[0];                        if (current_time < 10000) {                            if (readyQueue.empty()){                                printf("empty]\n");                            } else {                                print_ready(readyQueue, 2);                            }                        }                        new_process = current_time + t_cs;                        cpu_in_use = false;                        preempt = true;                    } else {                        if (current_time < 10000) {                            printf("time %dms: Process %s (tau %dms) completed I/O; added to ready queue [Q ", current_time, io_list[0].returnID().c_str(), io_list[0].return_prediction());                        }                        readyQueue.push_back(io_list[0]);                    }                } else {                    if (current_time < 10000) {                        printf("time %dms: Process %s (tau %dms) completed I/O; added to ready queue [Q ", current_time, io_list[0].returnID().c_str(), io_list[0].return_prediction());                    }                    readyQueue.push_back(io_list[0]);                    if (new_process <= current_time) {                        new_process = current_time + (t_cs/2);                    }                }                switch_count++;                if (io_list[0].returnBound() == 0) {                    cpu_switch_count++;                } else {                    io_switch_count++;                }                if (cpu_in_use) {                    std::sort(readyQueue.begin()+1, readyQueue.end(), shortestFirst);                } else {                    std::sort(readyQueue.begin(), readyQueue.end(), shortestFirst);                }                io_list.erase(io_list.begin());                if (!preempt) {                    if (current_time < 10000) {                        if (readyQueue.empty()){                            printf("empty]\n");                        } else {                            if (!cpu_in_use) {                                print_ready(readyQueue, 0);                            } else {                                print_ready(readyQueue, 1);                            }                        }                    }                } else {                    preempt = false;                }            }        }        if (processList.size() != 0) {            if (processList[0].returnArrivalTime() == current_time) { //add process to queue                if (first) {                    new_process = current_time + (t_cs/2);                }                if (current_time < 10000) {                    printf("time %dms: Process %s (tau %dms) arrived; added to ready queue [Q ", current_time, processList[0].returnID().c_str(), processList[0].return_prediction());                }                readyQueue.push_back(processList[0]);                if (cpu_in_use) {                    std::sort(readyQueue.begin()+1, readyQueue.end(), shortestFirst);                } else {                    std::sort(readyQueue.begin(), readyQueue.end(), shortestFirst);                }                if (current_time < 10000) {                    if (readyQueue.empty()){                        printf("empty]\n");                    } else {                        if (first) {                            print_ready(readyQueue, 0);                        } else if (cpu_in_use) {                            print_ready(readyQueue, 1);                        }                    }                }                processList.erase(processList.begin());            }        } else if (readyQueue.size() == 0 && io_list.size() == 0) {            current_time += (t_cs/2);            break;        }        current_time++;    }    double avg_turnaround = ceil(((turnaround + switch_count*(t_cs/2))/process_number)*1000)/1000;    double avg_cpu_turnaround = ceil(((cpu_turnaround + cpu_switch_count*(t_cs/2))/cpu_burst_number)*1000)/1000;    double avg_io_turnaround = ceil(((io_turnaround + io_switch_count*(t_cs/2))/io_burst_number)*1000)/1000;    printf("time %dms: Simulator ended for SRT [Q empty]\n", current_time);    total_wait_time-=(switch_count*(t_cs/2) + preemption_count*(t_cs));    io_wait_time-=(io_switch_count*(t_cs/2) + io_preemption_count*(t_cs));    cpu_wait_time-=(cpu_switch_count*(t_cs/2) + cpu_preemption_count*(t_cs));    average_wait_time = ceil((total_wait_time/process_number)*1000)/1000;    double average_cpu_wait = ceil((cpu_wait_time/cpu_burst_number)*1000)/1000;    double average_io_wait = ceil((io_wait_time/io_burst_number)*1000)/1000;    double CPU_UTIL = 0;    if (cpu_time != 0 && current_time != 0) {        CPU_UTIL = cpu_time/(current_time);        CPU_UTIL = ceil(CPU_UTIL * 100000) / 1000;    }    fprintf(outfile, "Algorithm SRT\n");    fprintf(outfile,"-- CPU utilization: %0.3f%%\n", CPU_UTIL);    fprintf(outfile,"-- CPU-bound average wait time: %0.3f ms\n", average_cpu_wait);    fprintf(outfile,"-- I/O-bound average wait time: %0.3f ms\n", average_io_wait);    fprintf(outfile,"-- overall average wait time: %0.3f ms\n", average_wait_time);    fprintf(outfile,"-- CPU-bound average turnaround time: %0.3f ms\n", avg_cpu_turnaround);    fprintf(outfile,"-- I/O-bound average turnaround time: %0.3f ms\n", avg_io_turnaround);    fprintf(outfile,"-- overall average turnaround time: %0.3f ms\n", avg_turnaround);    fprintf(outfile,"-- CPU-bound number of context switches: %d\n", cpu_switch_count + cpu_preemption_count);    fprintf(outfile,"-- I/O-bound number of context switches: %d\n", io_switch_count + io_preemption_count);    fprintf(outfile,"-- overall number of context switches: %d\n", switch_count + preemption_count);    fprintf(outfile,"-- CPU-bound number of preemptions: %d\n", cpu_preemption_count);    fprintf(outfile,"-- I/O-bound number of preemptions: %d\n", io_preemption_count);    fprintf(outfile,"-- overall number of preemptions: %d\n\n", preemption_count);}void RR(vector<Process> processList, FILE* outfile) {    printf("time 0ms: Simulator started for RR [Q empty]\n");    std::sort(processList.begin(), processList.end(), compareByArrival);    bool first = true;    bool cpu_in_use = false;    vector<Process> readyQueue;    vector<Process> io_list;    std::sort(io_list.begin(), io_list.end(), compareIO);    int current_time = 0;    double cpu_time = 0;    int cpu_counter = 0;    int new_process = 0;    int process_number = 0;    int switch_count = 0;    int cpu_switch_count = 0;    int io_switch_count = 0;    double cpu_wait_time = 0;    double io_wait_time = 0;    int cpu_burst_number = 0;    int io_burst_number = 0;    int preemption_count = 0;    int cpu_preemption_count = 0;    int io_preemption_count = 0;    double cpu_slice = 0;    double io_slice = 0;    double slice_count = 0;    for(long unsigned int x = 0; x < processList.size(); x++) {        process_number += processList[x].numBursts();        slice_count += processList[x].return_num_under_slice(tslice);        if (processList[x].returnBound() == 0) {            cpu_burst_number += processList[x].numBursts();            cpu_slice += processList[x].return_num_under_slice(tslice);        } else {            io_burst_number += processList[x].numBursts();            io_slice += processList[x].return_num_under_slice(tslice);        }    }    double turnaround = 0;    double cpu_turnaround = 0;    double io_turnaround = 0;    double total_wait_time = 0;    double average_wait_time;    while(true){        if (cpu_in_use) {            readyQueue[0].reduceBurst();            cpu_time++;            cpu_counter++;        }        if (cpu_in_use) {            if (readyQueue.size() > 1) {                waiting(readyQueue, 1);            }        } else {            waiting(readyQueue, 0);        }        if (readyQueue.size() > 0) {            if (cpu_in_use && current_time == readyQueue[0].returnEnd()){ //burst complete and switch                if (readyQueue[0].numBursts() != 1) {                    new_process = current_time + t_cs;                    readyQueue[0].burstComplete(current_time, (t_cs/2));                    if (current_time < 10000) {                        if (readyQueue[0].numBursts() == 1) {                            printf("time %dms: Process %s completed a CPU burst; %d burst to go [Q ", current_time, readyQueue[0].returnID().c_str(), readyQueue[0].numBursts());                        } else {                            printf("time %dms: Process %s completed a CPU burst; %d bursts to go [Q ", current_time, readyQueue[0].returnID().c_str(), readyQueue[0].numBursts());                        }                        if (readyQueue.size() == 0){                            printf("empty]\n");                        } else {                            print_ready(readyQueue, 1);                        }                        printf("time %dms: Process %s switching out of CPU; blocking on I/O until time %dms [Q ", current_time, readyQueue[0].returnID().c_str(), readyQueue[0].returnBlockTime());                    }                    if (readyQueue[0].return_preempt()) {                        readyQueue[0].unpreempt();                    }                    io_list.push_back(readyQueue[0]);                    std::sort(io_list.begin(), io_list.end(), compareIO);                    if (current_time < 10000) {                        if (readyQueue.size() == 0){                            printf("empty]\n");                        } else {                            print_ready(readyQueue, 1);                        }                    }                    readyQueue.erase(readyQueue.begin());                    cpu_in_use = false;                } else {                    new_process = current_time + t_cs;                    printf("time %dms: Process %s terminated [Q ", current_time, readyQueue[0].returnID().c_str());                    if (readyQueue.size() == 0){                        printf("empty]\n");                    } else {                        print_ready(readyQueue, 1);                    }                    switch_count++;                    if (readyQueue[0].returnBound() == 0) {                        cpu_switch_count++;                    } else {                        io_switch_count++;                    }                    readyQueue[0].set_turnaround();                    turnaround += readyQueue[0].return_turnaround();                    if (readyQueue[0].returnBound() == 0) {                        cpu_turnaround += readyQueue[0].return_turnaround();                    } else {                        io_turnaround += readyQueue[0].return_turnaround();                    }                    total_wait_time += readyQueue[0].return_wait_time();                    if (readyQueue[0].returnBound() == 0) {                        cpu_wait_time += readyQueue[0].return_wait_time();                    } else {                        io_wait_time += readyQueue[0].return_wait_time();                    }                    readyQueue.erase(readyQueue.begin());                    cpu_in_use = false;                }            }            if (!cpu_in_use && first && current_time == new_process ) { //Burst start if first                first = false;                if (current_time < 10000) {                    printf("time %dms: Process %s started using the CPU for %dms burst [Q ", current_time, readyQueue[0].returnID().c_str(), readyQueue[0].returnBurst());                    if (readyQueue.empty()){                        printf("empty]\n");                    } else {                        print_ready(readyQueue, 1);                    }                }                cpu_in_use = true;                cpu_counter = 0;                if (!readyQueue[0].return_preempt()) {                    readyQueue[0].save_burst();                }                readyQueue[0].add_end(current_time + readyQueue[0].returnBurst());            }            if (!cpu_in_use && current_time == new_process) { //Burst start                if (current_time < 10000) {                    if (readyQueue[0].return_preempt()) {                        printf("time %dms: Process %s started using the CPU for remaining %dms of %dms burst [Q ", current_time, readyQueue[0].returnID().c_str(), readyQueue[0].returnBurst(), readyQueue[0].return_saved_burst());                    } else {                        printf("time %dms: Process %s started using the CPU for %dms burst [Q ", current_time, readyQueue[0].returnID().c_str(), readyQueue[0].returnBurst());                    }                    if (readyQueue.empty()){                        printf("empty]\n");                    } else {                        print_ready(readyQueue, 1);                    }                }                cpu_in_use = true;                cpu_counter = 0;                if (!readyQueue[0].return_preempt()) {                    readyQueue[0].save_burst();                }                readyQueue[0].add_end(current_time + readyQueue[0].returnBurst());            }        }        if (cpu_in_use) {            if (cpu_counter == tslice) {                if (readyQueue.size() == 1) {                    if (current_time < 10000) {                        printf("time %dms: Time slice expired; no preemption because ready queue is empty [Q empty]\n",                               current_time);                    }                } else {                    if (current_time < 10000) {                        printf("time %dms: Time slice expired; preempting process %s with %dms remaining [Q ",                               current_time, readyQueue[0].returnID().c_str(), readyQueue[0].returnBurst());                        if (readyQueue.size() == 0) {                            printf("empty]\n");                        } else {                            print_ready(readyQueue, 1);                        }                    }                    preemption_count++;                    if (readyQueue[0].returnBound() == 0) {                        cpu_preemption_count++;                    } else {                        io_preemption_count++;                    }                    readyQueue[0].set_preempt();                    readyQueue.push_back(readyQueue[0]);                    readyQueue.erase(readyQueue.begin());                    cpu_in_use = false;                }                cpu_counter = 0;                new_process = current_time + t_cs;            }        }        if (io_list.size() != 0) { //completing IO Block            if (current_time == io_list[0].returnBlockTime()) {                if (current_time < 10000) {                    printf("time %dms: Process %s completed I/O; added to ready queue [Q ", current_time, io_list[0].returnID().c_str());                }                switch_count++;                if (io_list[0].returnBound() == 0) {                    cpu_switch_count++;                } else {                    io_switch_count++;                }                readyQueue.push_back(io_list[0]);                io_list.erase(io_list.begin());                if (current_time < 10000) {                    if (readyQueue.empty()){                        printf("empty]\n");                    } else {                        if ((current_time < new_process)) {                            print_ready(readyQueue, 1);                        } else {                            if (!cpu_in_use) {                                print_ready(readyQueue, 0);                            } else {                                print_ready(readyQueue, 1);                            }                        }                    }                }                if (new_process <= current_time) {                    new_process = current_time + (t_cs/2);                }            }        }        if (processList.size() != 0) {            if (processList[0].returnArrivalTime() == current_time) { //add process to queue                if (first) {                    new_process = current_time + (t_cs/2);                }                if (current_time < 10000) {                    printf("time %dms: Process %s arrived; added to ready queue [Q ", current_time, processList[0].returnID().c_str());                }                readyQueue.push_back(processList[0]);                if (current_time < 10000) {                    if (readyQueue.empty()){                        printf("empty]\n");                    } else {                        if (first) {                            print_ready(readyQueue, 0);                        } else if (cpu_in_use) {                            print_ready(readyQueue, 1);                        }                    }                }                processList.erase(processList.begin());            }        } else if (readyQueue.size() == 0 && io_list.size() == 0) {            current_time += (t_cs/2);            break;        }        current_time++;    }    double avg_turnaround = ceil(((turnaround + switch_count*(t_cs/2))/process_number)*1000)/1000;    double avg_cpu_turnaround = ceil(((cpu_turnaround + cpu_switch_count*(t_cs/2))/cpu_burst_number)*1000)/1000;    double avg_io_turnaround = ceil(((io_turnaround + io_switch_count*(t_cs/2))/io_burst_number)*1000)/1000;    printf("time %dms: Simulator ended for RR [Q empty]\n", current_time);    total_wait_time-=(switch_count*(t_cs/2) + preemption_count*(t_cs));    io_wait_time-=(io_switch_count*(t_cs/2) + io_preemption_count*(t_cs));    cpu_wait_time-=(cpu_switch_count*(t_cs/2) + cpu_preemption_count*(t_cs));    average_wait_time = ceil((total_wait_time/process_number)*1000)/1000;    double average_cpu_wait = ceil((cpu_wait_time/cpu_burst_number)*1000)/1000;    double average_io_wait = ceil((io_wait_time/io_burst_number)*1000)/1000;    double CPU_UTIL = 0;    if (cpu_time != 0 && current_time != 0) {        CPU_UTIL = cpu_time/(current_time);        CPU_UTIL = ceil(CPU_UTIL * 100000) / 1000;    }    double avg_under = 0;    double cpu_under = 0;    double io_under = 0;    if (slice_count != 0 && process_number != 0) {        avg_under = slice_count/(process_number);        avg_under = ceil(avg_under * 100000) / 1000;    }    if (cpu_slice != 0 && cpu_burst_number != 0) {        cpu_under = cpu_slice/(cpu_burst_number);        cpu_under = ceil(cpu_under * 100000) / 1000;    }    if (io_slice != 0 && io_burst_number != 0) {        io_under = io_slice/(io_burst_number);        io_under = ceil(io_under * 100000) / 1000;    }    fprintf(outfile, "Algorithm RR\n");    fprintf(outfile,"-- CPU utilization: %0.3f%%\n", CPU_UTIL);    fprintf(outfile,"-- CPU-bound average wait time: %0.3f ms\n", average_cpu_wait);    fprintf(outfile,"-- I/O-bound average wait time: %0.3f ms\n", average_io_wait);    fprintf(outfile,"-- overall average wait time: %0.3f ms\n", average_wait_time);    fprintf(outfile,"-- CPU-bound average turnaround time: %0.3f ms\n", avg_cpu_turnaround);    fprintf(outfile,"-- I/O-bound average turnaround time: %0.3f ms\n", avg_io_turnaround);    fprintf(outfile,"-- overall average turnaround time: %0.3f ms\n", avg_turnaround);    fprintf(outfile,"-- CPU-bound number of context switches: %d\n", cpu_switch_count + cpu_preemption_count);    fprintf(outfile,"-- I/O-bound number of context switches: %d\n", io_switch_count + io_preemption_count);    fprintf(outfile,"-- overall number of context switches: %d\n", switch_count + preemption_count);    fprintf(outfile,"-- CPU-bound number of preemptions: %d\n", cpu_preemption_count);    fprintf(outfile,"-- I/O-bound number of preemptions: %d\n", io_preemption_count);    fprintf(outfile,"-- overall number of preemptions: %d\n", preemption_count);    fprintf(outfile, "-- CPU-bound percentage of CPU bursts completed within one time slice: %0.3f%%\n", cpu_under);    fprintf(outfile, "-- I/O-bound percentage of CPU bursts completed within one time slice: %0.3f%%\n", io_under);    fprintf(outfile, "-- overall percentage of CPU bursts completed within one time slice: %0.3f%%\n", avg_under);}// define a function to generate the next exponential number for argv #3?double exp_dist(double lambda, int upper) {    while (true) {        double r = drand48();  /* uniform dist [0.00, 1.00), ln(0) = undefined */        /* generate the next pseudo-random value x */        double x = -log(r) / lambda;        /* log() is natural log */        //printf("%lf\n", x);        if (x <= upper) {            return x;        }    }}int main(int argc, char** argv){    if (argc != 9){        perror("ERROR: Not enough argument\n");        abort();    }    int processes = stoi(*(argv+1));    int cpu_bound = stoi(*(argv+2));    seed = stoi(*(argv+3));    lambda = stod(*(argv+4));    bound = stoi(*(argv+5));    t_cs = stoi(*(argv+6));    alpha = stof(*(argv+7));    tslice = stoi(*(argv+8));    if (processes <= 0){        perror("ERROR: # of processes not greater than zero\n");        abort();    }    if (processes > 260) {        perror("ERROR: # of processes too great\n");        abort();    }    if (lambda <= 0) {        perror("ERROR: lambda 0 or less\n");        abort();    }    if (cpu_bound > processes) {        perror("ERROR: cpu_bound cannot be greater than processes\n");        abort();    }    if (cpu_bound < 0) {        perror("ERROR: cpu_bound cannot be less than 0\n");        abort();    }    if (bound < 0) {        perror("ERROR: upper bound cannot be less than 0\n");        abort();    }    if (t_cs % 2 != 0 || t_cs < 0){        perror("ERROR: time either not even or negative\n");        abort();    }    if (alpha > 1 || alpha < 0){        perror("ERROR: alpha not between 0 and 1\n");        abort();    }    if (tslice < 0){        perror("ERROR: time slice not positive\n");        abort();    }    srand48(seed);    if (cpu_bound == 1) {        printf("<<< PROJECT PART I\n"               "<<< -- process set (n=%d) with %d CPU-bound process\n"               "<<< -- seed=%d; lambda=%lf; bound=%d\n", processes, cpu_bound, seed, lambda, bound);    } else {        printf("<<< PROJECT PART I\n"               "<<< -- process set (n=%d) with %d CPU-bound processes\n"               "<<< -- seed=%d; lambda=%lf; bound=%d\n", processes, cpu_bound, seed, lambda, bound);    }    vector<Process> processList;    //process creation loop    int letter = 65; // 65 is A, but can only go up to 90 which is Z    int number = 0;    for(int i = 0; i < processes; i++) {        char first = char(letter);        string ID = first + to_string(number);        if (i < cpu_bound) {            processList.emplace_back(ID, 0, int(1/lambda));        } else {            processList.emplace_back(ID, 1, int(1/lambda));        }        number++;        if (number > 9) {            number = 0;            letter++;        }    }    //process loop    for (int i = 0; i < processes; i++) {        int arrival = floor(exp_dist(lambda, bound));        int bursts = ceil(drand48() * 32);        processList[i].add_arrival(arrival);        CPU_total_bursts += bursts; //adds to total CPU bursts        IO_total_bursts += bursts-1; //adds to total IO bursts        if (i < cpu_bound) { //If the process is CPU Bound            CB_CPU_bursts += bursts;            CB_IO_bursts += bursts-1;            if (bursts == 1) {                printf("CPU-bound process %s: arrival time %dms; %d CPU burst:\n", processList[i].returnID().c_str(), arrival, bursts);            } else {                printf("CPU-bound process %s: arrival time %dms; %d CPU bursts:\n", processList[i].returnID().c_str(), arrival, bursts);            }        } else { //If the process is I/O Bound            IB_CPU_bursts += bursts;            IB_IO_bursts += bursts-1;            if (bursts == 1) {                printf("I/O-bound process %s: arrival time %dms; %d CPU burst:\n", processList[i].returnID().c_str(), arrival, bursts);            } else {                printf("I/O-bound process %s: arrival time %dms; %d CPU bursts:\n", processList[i].returnID().c_str(), arrival, bursts);            }        }        //processes each CPU Burst for the process        for(int j = 0; j < bursts; j++) {            CPU_burst = ceil(exp_dist(lambda, bound)); //CPU burst time of burst            if (j != bursts-1) {                //will get I/O burst time on all bursts except last                IO_burst = ceil(exp_dist(lambda, bound));            }            if (i < cpu_bound) { //If the process is CPU Bound                CPU_burst *= 4;                CB_CPU_time += CPU_burst;                if (j != bursts-1) { //add IO burst time on all bursts but last                    CB_IO_time += IO_burst;                }            } else { //If the process and I/O bound                if (j != bursts-1) { //we get I/O burst time if not last burst                    IO_burst *= 8;                    IB_IO_time += IO_burst;                }                IB_CPU_time += CPU_burst;            }            //adds the total burst time for CPU and IO            CPU_burst_time += CPU_burst;            if (j != bursts-1) {                IO_burst_time += IO_burst;            }            processList[i].addBurst(CPU_burst, IO_burst);            if (j == bursts-1) {                //printf("==> CPU burst %dms\n", CPU_burst);            } else {                //printf("==> CPU burst %dms ==> I/O burst %dms\n", CPU_burst, IO_burst);            }        }    }    printf("<<< PROJECT PART II\n"           "<<< -- t_cs=%dms; alpha=%.2f; t_slice=%dms\n", t_cs, alpha, tslice);    //Calculates the averages with ceiling roundings    double CB_CPU_avg = 0; // CPU bound average CPU burst time    if (CB_CPU_time != 0 && CB_CPU_bursts != 0) {        CB_CPU_avg = CB_CPU_time/CB_CPU_bursts;        CB_CPU_avg = ceil(CB_CPU_avg * 1000) / 1000;    }    double IB_CPU_avg = 0; // I/O bound average CPU burst time    if (IB_CPU_time != 0 && IB_CPU_bursts != 0) {        IB_CPU_avg = IB_CPU_time/IB_CPU_bursts;        IB_CPU_avg = ceil(IB_CPU_avg * 1000) / 1000;    }    double CPU_avg = 0; // overall average CPU burst time    if (CPU_burst_time != 0 && CPU_total_bursts != 0) {        CPU_avg = CPU_burst_time/CPU_total_bursts;        CPU_avg = ceil(CPU_avg * 1000) / 1000;    }    double CB_IO_avg = 0; // CPU bound average IO bursts time    if (CB_IO_time != 0 && CB_IO_bursts != 0) {        CB_IO_avg = CB_IO_time/CB_IO_bursts;        CB_IO_avg = ceil(CB_IO_avg * 1000) / 1000;    }    double IB_IO_avg = 0; // IO bound average IO burst time    if (IB_IO_time != 0 && IB_IO_bursts != 0) {        IB_IO_avg = IB_IO_time/IB_IO_bursts;        IB_IO_avg = ceil(IB_IO_avg * 1000) / 1000;    }    double IO_avg = 0; // overall average IO burst time    if (IO_burst_time != 0 && IO_total_bursts != 0) {        IO_avg = IO_burst_time/IO_total_bursts;        IO_avg = ceil(IO_avg * 1000) / 1000;    }    FILE* outfile = fopen("simout.txt", "w");    if(outfile == NULL){        perror("ERROR: failed to create file\n");        abort();    }    fprintf(outfile, "-- number of processes: %d\n", processes);    fprintf(outfile, "-- number of CPU-bound processes: %d\n", cpu_bound);    fprintf(outfile, "-- number of I/O-bound processes: %d\n", processes-cpu_bound);    fprintf(outfile, "-- CPU-bound average CPU burst time: %0.3f ms\n", CB_CPU_avg);    fprintf(outfile, "-- I/O-bound average CPU burst time: %0.3f ms\n", IB_CPU_avg);    fprintf(outfile, "-- overall average CPU burst time: %0.3f ms\n", CPU_avg);    fprintf(outfile, "-- CPU-bound average I/O burst time: %0.3f ms\n", CB_IO_avg);    fprintf(outfile, "-- I/O-bound average I/O burst time: %0.3f ms\n", IB_IO_avg);    fprintf(outfile, "-- overall average I/O burst time: %0.3f ms\n\n", IO_avg);    FCFS(processList, outfile);    printf("\n");    SJF(processList, outfile);    printf("\n");    SRT(processList, outfile);    printf("\n");    RR(processList, outfile);    fclose(outfile);    return 0;}